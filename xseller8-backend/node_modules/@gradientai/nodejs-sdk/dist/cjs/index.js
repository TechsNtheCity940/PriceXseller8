"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Gradient = void 0;
const axios_1 = require("axios");
const fs_1 = require("fs");
const path_1 = require("path");
const api_1 = require("./api");
const embeddingsModel_1 = require("./embedding/embeddingsModel");
const filesApiManager_1 = require("./files/filesApiManager");
const env_1 = require("./helpers/env");
const typeChecking_1 = require("./helpers/typeChecking");
const wait_1 = require("./helpers/wait");
const abstractModel_1 = require("./model/abstractModel");
const baseModel_1 = require("./model/baseModel");
const modelAdapter_1 = require("./model/modelAdapter");
const ragCollection_1 = require("./rag/ragCollection");
class Gradient {
    constructor({ accessToken = (0, env_1.getRequiredEnvValue)("GRADIENT_ACCESS_TOKEN"), host = (0, env_1.getOptionalEnvValue)("GRADIENT_API_URL"), workspaceId = (0, env_1.getRequiredEnvValue)("GRADIENT_WORKSPACE_ID"), }) {
        this.deserializeModelInstance = (apiModel) => {
            switch (apiModel.type) {
                case "baseModel":
                    return new baseModel_1.BaseModel({
                        apiInstance: this.modelsApi,
                        capabilities: apiModel.capabilities,
                        id: apiModel.id,
                        slug: apiModel.slug,
                        workspaceId: this.workspaceId,
                    });
                case "modelAdapter":
                    return new modelAdapter_1.ModelAdapter({
                        apiInstance: this.modelsApi,
                        baseModelId: apiModel.baseModelId,
                        id: apiModel.id,
                        name: apiModel.name,
                        workspaceId: this.workspaceId,
                    });
                default:
                    return (0, typeChecking_1.expectNever)(apiModel);
            }
        };
        this.deserializeEmbeddingsModel = (apiModel) => {
            return new embeddingsModel_1.EmbeddingsModel({
                apiInstance: this.embeddingsApi,
                slug: apiModel.slug,
                workspaceId: this.workspaceId,
            });
        };
        this.getBaseModel = ({ baseModelSlug, }) => __awaiter(this, void 0, void 0, function* () {
            const models = yield this.listModels({ onlyBase: true });
            const model = models.find(({ slug }) => slug === baseModelSlug);
            if (!model) {
                throw new Error(`Base model not found for slug ${baseModelSlug}`);
            }
            return model;
        });
        this.getModelAdapter = ({ modelAdapterId, }) => __awaiter(this, void 0, void 0, function* () {
            const { data: { baseModelId, id, name }, } = yield this.modelsApi.getModel({
                id: modelAdapterId,
                xGradientWorkspaceId: this.workspaceId,
            });
            return new modelAdapter_1.ModelAdapter({
                apiInstance: this.modelsApi,
                baseModelId,
                id,
                name,
                workspaceId: this.workspaceId,
            });
        });
        this.listModels = ({ capability = "any", onlyBase, }) => __awaiter(this, void 0, void 0, function* () {
            const { data: { models }, } = yield this.modelsApi.listModels({
                capability,
                onlyBase,
                xGradientWorkspaceId: this.workspaceId,
            });
            return models
                .map(this.deserializeModelInstance)
                .filter((model) => model instanceof (onlyBase ? baseModel_1.BaseModel : abstractModel_1.Model));
        });
        this.getEmbeddingsModel = ({ slug, }) => __awaiter(this, void 0, void 0, function* () {
            const embeddingsModels = yield this.listEmbeddingsModels({});
            const embeddingsModel = embeddingsModels.find((o) => o.slug === slug);
            if (!embeddingsModel) {
                throw new Error(`Embeddings model not found for slug ${slug}`);
            }
            return embeddingsModel;
        });
        this.listEmbeddingsModels = ({}) => __awaiter(this, void 0, void 0, function* () {
            const { data: { embeddingsModels }, } = yield this.embeddingsApi.listEmbeddings({
                xGradientWorkspaceId: this.workspaceId,
            });
            return embeddingsModels.map(this.deserializeEmbeddingsModel);
        });
        this.analyzeSentiment = ({ document, examples, }) => __awaiter(this, void 0, void 0, function* () {
            const { data: { sentiment }, } = yield this.blocksApi.analyzeSentiment({
                xGradientWorkspaceId: this.workspaceId,
                analyzeSentimentBodyParams: { document, examples },
            });
            return { sentiment };
        });
        this.extract = ({ document, schema, }) => __awaiter(this, void 0, void 0, function* () {
            const { data: { entity }, } = yield this.blocksApi.extractEntity({
                xGradientWorkspaceId: this.workspaceId,
                extractEntityBodyParams: { document, schema },
            });
            return { entity: entity };
        });
        this.extractPdf = ({ filepath, }) => __awaiter(this, void 0, void 0, function* () {
            const { data: { pages, text, title }, } = yield this.blocksApi.extractPdf({
                xGradientWorkspaceId: this.workspaceId,
                file: (0, fs_1.createReadStream)(filepath),
            });
            return { pages, text, title };
        });
        this.transcribeAudio = ({ filepath, }) => __awaiter(this, void 0, void 0, function* () {
            const { id: fileId } = yield this.filesApiManager.uploadFile({
                filepath,
                type: "audioFile",
            });
            const { data: { transcriptionId }, } = yield this.blocksApi.createAudioTranscription({
                createAudioTranscriptionBodyParams: {
                    fileId,
                },
                xGradientWorkspaceId: this.workspaceId,
            });
            while (true) {
                const { data } = yield this.blocksApi.getAudioTranscription({
                    transcriptionId,
                    xGradientWorkspaceId: this.workspaceId,
                });
                switch (data.status) {
                    case "pending":
                    case "pendingCancellation":
                    case "running": {
                        yield (0, wait_1.wait)(1000);
                        break;
                    }
                    case "cancelled":
                    case "failed": {
                        throw new Error("Unable to get transcription");
                    }
                    case "succeeded": {
                        return { text: data.result.text };
                    }
                    default: {
                        return (0, typeChecking_1.expectNever)(data);
                    }
                }
            }
        });
        this.answer = ({ question, source, }) => __awaiter(this, void 0, void 0, function* () {
            const { data: { answer, ragContext }, } = yield this.blocksApi.generateAnswer({
                xGradientWorkspaceId: this.workspaceId,
                generateAnswerBodyParams: { question, source },
            });
            return { answer, ragContext };
        });
        this.personalize = ({ document, audienceDescription, }) => __awaiter(this, void 0, void 0, function* () {
            const { data: { personalizedDocument }, } = yield this.blocksApi.personalizeDocument({
                xGradientWorkspaceId: this.workspaceId,
                personalizeDocumentBodyParams: { document, audienceDescription },
            });
            return { personalizedDocument };
        });
        this.summarize = ({ document, examples, length, }) => __awaiter(this, void 0, void 0, function* () {
            const { data: { summary }, } = yield this.blocksApi.summarizeDocument({
                xGradientWorkspaceId: this.workspaceId,
                summarizeDocumentBodyParams: {
                    document,
                    length,
                    examples: examples,
                },
            });
            return { summary };
        });
        this.getRagCollection = ({ id, }) => __awaiter(this, void 0, void 0, function* () {
            const { data: ragCollection } = yield this.ragApi.getRagCollection({
                xGradientWorkspaceId: this.workspaceId,
                id,
            });
            return new ragCollection_1.RagCollection({
                chunker: ragCollection.chunker,
                files: ragCollection.files,
                filesApiManager: this.filesApiManager,
                id: ragCollection.id,
                name: ragCollection.name,
                ragApi: this.ragApi,
                workspaceId: this.workspaceId,
            });
        });
        /**
         *  Files are not present in the list call. To retrieve the files use `getRagCollection`.
         */
        this.listRagCollections = ({}) => __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.ragApi.listRagCollections({
                xGradientWorkspaceId: this.workspaceId,
            });
            return data.ragCollections.map(({ id, name, chunker }) => new ragCollection_1.RagCollection({
                chunker,
                files: [],
                filesApiManager: this.filesApiManager,
                id,
                name,
                ragApi: this.ragApi,
                workspaceId: this.workspaceId,
            }));
        });
        this.createRagCollection = ({ chunker, filepaths, name, slug, }) => __awaiter(this, void 0, void 0, function* () {
            let files;
            if (!(0, typeChecking_1.isUndefined)(filepaths)) {
                const uploadedFiles = yield this.filesApiManager.uploadFiles({
                    filepaths,
                    type: "ragUserFile",
                });
                files = uploadedFiles.files.map(({ filepath, id }) => ({
                    id,
                    name: (0, path_1.basename)(filepath),
                }));
            }
            const { data: { id }, } = yield this.ragApi.createRagCollection({
                createRagCollectionBodyParams: {
                    files,
                    name,
                    chunker,
                    slug,
                },
                xGradientWorkspaceId: this.workspaceId,
            });
            return this.getRagCollection({ id });
        });
        const configuration = new api_1.Configuration({
            accessToken,
            basePath: host,
        });
        const axiosClient = axios_1.default.create({
            maxBodyLength: Infinity,
        });
        this.blocksApi = new api_1.BlocksApi(configuration, undefined, axiosClient);
        this.embeddingsApi = new api_1.EmbeddingsApi(configuration, undefined, axiosClient);
        this.filesApiManager = new filesApiManager_1.FilesApiManager({
            filesApi: new api_1.FilesApi(configuration, undefined, axiosClient),
            workspaceId,
        });
        this.modelsApi = new api_1.ModelsApi(configuration, undefined, axiosClient);
        this.ragApi = new api_1.RAGApi(configuration, undefined, axiosClient);
        this.workspaceId = workspaceId;
    }
}
exports.Gradient = Gradient;
// TODO: Dummy todo so that Copybaras replace transform doesn't complain that it doesn't have any todos.
